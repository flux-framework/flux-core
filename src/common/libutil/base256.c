/************************************************************\
 * Copyright 2023 Lawrence Livermore National Security, LLC
 * (c.f. AUTHORS, NOTICE.LLNS, COPYING)
 *
 * This file is part of the Flux resource manager framework.
 * For details, see https://github.com/flux-framework.
 *
 * SPDX-License-Identifier: LGPL-3.0
\************************************************************/
/* base256.c - a binary to emoji encoding
 *
 * Adapted from https://github.com/Equim-chan/libb256
 * Copyright (c) 2017, Equim
 * BSD 3-Clause License
 *
 * Specification:
 *
 * base256 encoding uses two tables to transform a single byte
 * into a single emoji. The tables can be found in table.go. In
 * this implementation, these tables are utilized circularly when
 * encoding.
 *
 * To achieve the best compatibility, all the emojis are picked
 * from the classic version and each of them is guaranteed to be
 * 4 bytes long in UTF-8.
 */

#if HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <errno.h>
#include <string.h>

#include "ccan/str/str.h"
#include "base256.h"

static const char* enc_tab[2][256] = {{
    "ğŸ˜€", "ğŸ˜", "ğŸ˜‚", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜…", "ğŸ˜†", "ğŸ˜‰", "ğŸ˜Š", "ğŸ˜‹", "ğŸ˜", "ğŸ˜", "ğŸ˜˜", "ğŸ˜—", "ğŸ˜™", "ğŸ˜š",
    "ğŸ™‚", "ğŸ¤—", "ğŸ¤”", "ğŸ˜", "ğŸ˜‘", "ğŸ˜¶", "ğŸ™„", "ğŸ˜", "ğŸ˜£", "ğŸ˜¥", "ğŸ˜®", "ğŸ¤", "ğŸ˜¯", "ğŸ˜ª", "ğŸ˜«", "ğŸ˜´",
    "ğŸ˜Œ", "ğŸ¤“", "ğŸ˜›", "ğŸ˜œ", "ğŸ˜", "ğŸ˜’", "ğŸ˜“", "ğŸ˜”", "ğŸ˜•", "ğŸ™ƒ", "ğŸ¤‘", "ğŸ˜²", "ğŸ™", "ğŸ˜–", "ğŸ˜", "ğŸ˜Ÿ",
    "ğŸ˜¤", "ğŸ˜¢", "ğŸ˜­", "ğŸ˜¦", "ğŸ˜¨", "ğŸ˜©", "ğŸ˜¬", "ğŸ˜°", "ğŸ˜±", "ğŸ˜³", "ğŸ˜µ", "ğŸ˜¡", "ğŸ˜ ", "ğŸ˜‡", "ğŸ˜·", "ğŸ¤’",
    "ğŸ¤•", "ğŸ˜ˆ", "ğŸ‘¿", "ğŸ‘¹", "ğŸ‘º", "ğŸ’€", "ğŸ‘»", "ğŸ‘½", "ğŸ‘¾", "ğŸ¤–", "ğŸ’©", "ğŸ˜º", "ğŸ˜¸", "ğŸ˜¹", "ğŸ˜»", "ğŸ˜¼",
    "ğŸ˜½", "ğŸ™€", "ğŸ˜¿", "ğŸ˜¾", "ğŸ™ˆ", "ğŸ™‰", "ğŸ™Š", "ğŸ‘¦", "ğŸ‘§", "ğŸ‘¨", "ğŸ‘©", "ğŸ‘´", "ğŸ‘µ", "ğŸ‘¶", "ğŸ‘¼", "ğŸ‘®",
    "ğŸ•µ", "ğŸ’‚", "ğŸ‘·", "ğŸ‘³", "ğŸ‘±", "ğŸ…", "ğŸ‘¸", "ğŸ‘°", "ğŸ‘²", "ğŸ™", "ğŸ™", "ğŸ™…", "ğŸ™†", "ğŸ’", "ğŸ™‹", "ğŸ™‡",
    "ğŸ’†", "ğŸ’‡", "ğŸš¶", "ğŸƒ", "ğŸ’ƒ", "ğŸ‘¯", "ğŸ•´", "ğŸ—£", "ğŸ‘¤", "ğŸ‘¥", "ğŸ‡", "ğŸ‚", "ğŸŒ", "ğŸ„", "ğŸš£", "ğŸŠ",
    "ğŸ‹", "ğŸš´", "ğŸšµ", "ğŸ", "ğŸ", "ğŸ‘«", "ğŸ‘¬", "ğŸ‘­", "ğŸ’", "ğŸ’‘", "ğŸ‘ª", "ğŸ’ª", "ğŸ‘ˆ", "ğŸ‘‰", "ğŸ‘†", "ğŸ–•",
    "ğŸ‘‡", "ğŸ––", "ğŸ¤˜", "ğŸ–", "ğŸ‘Œ", "ğŸ‘", "ğŸ‘", "ğŸ‘Š", "ğŸ‘‹", "ğŸ‘", "ğŸ‘", "ğŸ™Œ", "ğŸ™", "ğŸ’…", "ğŸ‘‚", "ğŸ‘ƒ",
    "ğŸ‘£", "ğŸ‘€", "ğŸ‘", "ğŸ‘…", "ğŸ‘„", "ğŸ’‹", "ğŸ’˜", "ğŸ’“", "ğŸ’”", "ğŸ’•", "ğŸ’–", "ğŸ’—", "ğŸ’™", "ğŸ’š", "ğŸ’›", "ğŸ’œ",
    "ğŸ’", "ğŸ’", "ğŸ’Ÿ", "ğŸ’Œ", "ğŸ’¤", "ğŸ’¢", "ğŸ’£", "ğŸ’¥", "ğŸ’¦", "ğŸ’¨", "ğŸ’«", "ğŸ’¬", "ğŸ—¨", "ğŸ—¯", "ğŸ’­", "ğŸ•³",
    "ğŸ‘“", "ğŸ•¶", "ğŸ‘”", "ğŸ‘•", "ğŸ‘–", "ğŸ‘—", "ğŸ‘˜", "ğŸ‘™", "ğŸ‘š", "ğŸ‘›", "ğŸ‘œ", "ğŸ‘", "ğŸ›", "ğŸ’", "ğŸ‘", "ğŸ‘Ÿ",
    "ğŸ‘ ", "ğŸ‘¡", "ğŸ‘¢", "ğŸ‘‘", "ğŸ‘’", "ğŸ©", "ğŸ“", "ğŸ“¿", "ğŸ’„", "ğŸ’", "ğŸ’", "ğŸµ", "ğŸ’", "ğŸ¶", "ğŸ•", "ğŸ©",
    "ğŸº", "ğŸ±", "ğŸˆ", "ğŸ¦", "ğŸ¯", "ğŸ…", "ğŸ†", "ğŸ´", "ğŸ", "ğŸ¦„", "ğŸ®", "ğŸ‚", "ğŸƒ", "ğŸ„", "ğŸ·", "ğŸ–",
    "ğŸ—", "ğŸ½", "ğŸ", "ğŸ‘", "ğŸ", "ğŸª", "ğŸ«", "ğŸ˜", "ğŸ­", "ğŸ", "ğŸ€", "ğŸ¹", "ğŸ°", "ğŸ‡", "ğŸ¿", "ğŸ»"
}, {
    "ğŸ¨", "ğŸ¼", "ğŸ¾", "ğŸ¦ƒ", "ğŸ”", "ğŸ“", "ğŸ£", "ğŸ¤", "ğŸ¥", "ğŸ¦", "ğŸ§", "ğŸ•Š", "ğŸ¸", "ğŸŠ", "ğŸ¢", "ğŸ",
    "ğŸ²", "ğŸ‰", "ğŸ³", "ğŸ‹", "ğŸ¬", "ğŸŸ", "ğŸ ", "ğŸ¡", "ğŸ™", "ğŸš", "ğŸ¦€", "ğŸŒ", "ğŸ›", "ğŸœ", "ğŸ", "ğŸ",
    "ğŸ•·", "ğŸ•¸", "ğŸ¦‚", "ğŸ’", "ğŸŒ¸", "ğŸ’®", "ğŸµ", "ğŸŒ¹", "ğŸŒº", "ğŸŒ»", "ğŸŒ¼", "ğŸŒ·", "ğŸŒ±", "ğŸŒ²", "ğŸŒ³", "ğŸŒ´",
    "ğŸŒµ", "ğŸŒ¾", "ğŸŒ¿", "ğŸ€", "ğŸ", "ğŸ‚", "ğŸƒ", "ğŸ‡", "ğŸˆ", "ğŸ‰", "ğŸŠ", "ğŸ‹", "ğŸŒ", "ğŸ", "ğŸ", "ğŸ",
    "ğŸ", "ğŸ‘", "ğŸ’", "ğŸ“", "ğŸ…", "ğŸ†", "ğŸŒ½", "ğŸŒ¶", "ğŸ„", "ğŸŒ°", "ğŸ", "ğŸ§€", "ğŸ–", "ğŸ—", "ğŸ”", "ğŸŸ",
    "ğŸ•", "ğŸŒ­", "ğŸŒ®", "ğŸŒ¯", "ğŸ³", "ğŸ²", "ğŸ¿", "ğŸ±", "ğŸ˜", "ğŸ™", "ğŸš", "ğŸ›", "ğŸœ", "ğŸ", "ğŸ ", "ğŸ¢",
    "ğŸ£", "ğŸ¤", "ğŸ¥", "ğŸ¡", "ğŸ¦", "ğŸ§", "ğŸ¨", "ğŸ©", "ğŸª", "ğŸ‚", "ğŸ°", "ğŸ«", "ğŸ¬", "ğŸ­", "ğŸ®", "ğŸ¯",
    "ğŸ¼", "ğŸµ", "ğŸ¶", "ğŸ¾", "ğŸ·", "ğŸ¸", "ğŸ¹", "ğŸº", "ğŸ»", "ğŸ½", "ğŸ´", "ğŸ”ª", "ğŸº", "ğŸŒ", "ğŸŒ", "ğŸŒ",
    "ğŸŒ", "ğŸ—º", "ğŸ—¾", "ğŸ”", "ğŸŒ‹", "ğŸ—»", "ğŸ•", "ğŸ–", "ğŸœ", "ğŸ", "ğŸ", "ğŸŸ", "ğŸ›", "ğŸ—", "ğŸ˜", "ğŸ™",
    "ğŸš", "ğŸ ", "ğŸ¡", "ğŸ¢", "ğŸ£", "ğŸ¤", "ğŸ¥", "ğŸ¦", "ğŸ¨", "ğŸ©", "ğŸª", "ğŸ«", "ğŸ¬", "ğŸ­", "ğŸ¯", "ğŸ°",
    "ğŸ’’", "ğŸ—¼", "ğŸ—½", "ğŸ•Œ", "ğŸ•", "ğŸ•‹", "ğŸŒ", "ğŸŒƒ", "ğŸŒ„", "ğŸŒ…", "ğŸŒ†", "ğŸŒ‡", "ğŸŒ‰", "ğŸŒŒ", "ğŸ ", "ğŸ¡",
    "ğŸ¢", "ğŸ’ˆ", "ğŸª", "ğŸ­", "ğŸ–¼", "ğŸ¨", "ğŸ°", "ğŸš‚", "ğŸšƒ", "ğŸš„", "ğŸš…", "ğŸš†", "ğŸš‡", "ğŸšˆ", "ğŸš‰", "ğŸšŠ",
    "ğŸš", "ğŸš", "ğŸš‹", "ğŸšŒ", "ğŸš", "ğŸš", "ğŸš", "ğŸš‘", "ğŸš’", "ğŸš“", "ğŸš”", "ğŸš•", "ğŸš–", "ğŸš—", "ğŸš˜", "ğŸš™",
    "ğŸšš", "ğŸš›", "ğŸšœ", "ğŸš²", "ğŸš", "ğŸ›£", "ğŸ›¤", "ğŸš¨", "ğŸš¥", "ğŸš¦", "ğŸš§", "ğŸš¤", "ğŸ›³", "ğŸ›¥", "ğŸš¢", "ğŸ›©",
    "ğŸ›«", "ğŸ›¬", "ğŸ’º", "ğŸš", "ğŸšŸ", "ğŸš ", "ğŸš¡", "ğŸš€", "ğŸ›°", "ğŸ›", "ğŸšª", "ğŸ›Œ", "ğŸ›", "ğŸ›‹", "ğŸš½", "ğŸš¿",
    "ğŸ›€", "ğŸ›", "ğŸ•°", "ğŸŒ", "ğŸŒ", "ğŸŒš", "ğŸŒ‘", "ğŸŒ’", "ğŸŒ“", "ğŸŒ”", "ğŸŒ•", "ğŸŒ–", "ğŸŒ—", "ğŸŒ˜", "ğŸŒœ", "ğŸŒ›"
}};

int base256_encode (char *buf,
                    int buflen,
                    void *data,
                    int datalen)
{
    register unsigned char table = 0;
    int i = 0;
    int n = 0;

    if (buf == NULL || data == NULL || buflen <= 0 || datalen < 0) {
        errno = EINVAL;
        return -1;
    }

    /* Copy prefix */
    memcpy (buf, BASE64_PREFIX, strlen(BASE64_PREFIX));
    n += strlen (BASE64_PREFIX);

    while (i < datalen && n < buflen - 2) {
        memcpy (buf + n, enc_tab[table][((unsigned char *) data)[i]], 4);

        table = 1 - table;
        i++;
        n += 4;
    }
    buf[n++] = '\0';
    return n;
}

static int base256_lookup (const char *c, char *result)
{
    for (int i = 0; i < 512; i++) {
        const char *index = enc_tab[i / 256][i % 256];
        if (memcmp (c, index, 4) == 0) {
            *result = (char) i;
            return 0;
        }
    }
    errno = ENOENT;
    return -1;
}

int base256_decode (void *buf, int buflen, const char *in)
{
    int in_size;
    const char *cur;
    int i = 0;
    int n = 0;

    if (buf == NULL || in == NULL || buflen <= 0) {
        errno = EINVAL;
        return -1;
    }

    if (!strstarts (in, BASE64_PREFIX)) {
        errno = EINVAL;
        return -1;
    }

    in_size = strlen (in);

    /* Skip past prefix */
    i += strlen (BASE64_PREFIX);
    do {
        char c;
        cur = in + i;
        if (base256_lookup (cur, &c) < 0)
            return -1;
        ((char *)buf)[n] = c;
        i += 4;
        n++;
    } while (i < in_size && n < buflen);

    return n;
}
