/************************************************************\
 * Copyright 2025 Lawrence Livermore National Security, LLC
 * (c.f. AUTHORS, NOTICE.LLNS, COPYING)
 *
 * This file is part of the Flux resource manager framework.
 * For details, see https://github.com/flux-framework.
 *
 * SPDX-License-Identifier: LGPL-3.0
\************************************************************/

/* upmi_config.c - plugin for flux's [bootstrap] table
 *
 * 'config' and 'hostname' arguments must be passed in the 'args'
 * of upmi_create_ex().
 *
 * If [bootstrap] is present in the config, upmi_create_ex() is successful.
 * Any parse errors cause upmi_initialize() to fail.
 *
 * Business cards are populated for all defined hosts.
 * N.B. since the topology is unknown here, connect URIs may be populated
 * for leaf nodes even though they will be unused.
 *
 * Public keys are not included in the business cards generated by this
 * method.  The caller should assume the same cert is used across all nodes.
 *
 * The kvs put and get operations are functional, but since there is no
 * collective exchange in this method, the kvs scope is local only.
 */

#if HAVE_CONFIG_H
#include "config.h"
#endif
#include <flux/core.h>
#include <jansson.h>
#include <stdlib.h>
#include <errno.h>

#include "src/common/libutil/errprintf.h"
#include "src/common/libhostlist/hostlist.h"
#include "src/common/libfluxutil/conf_bootstrap.h"
#include "ccan/str/str.h"

#include "upmi.h"
#include "upmi_plugin.h"
#include "bizcard.h"

#define MAX_URI 2048

struct plugin_ctx {
    flux_conf_t *conf;
    json_t *kvs;
    json_t *hosts;
    char *hostname;
    int rank;
    int size;
};

static const char *plugin_name = "config";

static void plugin_ctx_destroy (struct plugin_ctx *ctx)
{
    if (ctx) {
        int saved_errno = errno;
        flux_conf_decref (ctx->conf);
        json_decref (ctx->hosts);
        json_decref (ctx->kvs);
        free (ctx->hostname);
        free (ctx);
        errno = saved_errno;
    }
}

static struct plugin_ctx *plugin_ctx_create (json_t *config,
                                             const char *hostname)
{
    struct plugin_ctx *ctx;

    if (!(ctx = calloc (1, sizeof (*ctx))))
        return NULL;
    if (!(ctx->hostname = strdup (hostname)))
        goto error;
    if (!(ctx->conf = flux_conf_pack ("O", config)))
        goto error;
    if (!(ctx->kvs = json_object ())) {
        errno = ENOMEM;
        goto error;
    }
    return ctx;
error:
    plugin_ctx_destroy (ctx);
    return NULL;
}

static int set_string (json_t *o, const char *key, const char *s)
{
    json_t *val;

    if (!(val = json_string (s))
        || json_object_set_new (o, key, val) < 0) {
        json_decref (val);
        return -1;
    }
    return 0;
}

static int op_put (flux_plugin_t *p,
                   const char *topic,
                   flux_plugin_arg_t *args,
                   void *data)
{
    struct plugin_ctx *ctx = flux_plugin_aux_get (p, plugin_name);
    const char *key;
    const char *value;

    if (flux_plugin_arg_unpack (args,
                                FLUX_PLUGIN_ARG_IN,
                                "{s:s s:s}",
                                "key", &key,
                                "value", &value) < 0)
        return upmi_seterror (p, args, "error unpacking put arguments");
    if (set_string (ctx->kvs, key, value) < 0)
        return upmi_seterror (p, args, "dictionary update error");
    return 0;
}

static int op_get (flux_plugin_t *p,
                   const char *topic,
                   flux_plugin_arg_t *args,
                   void *data)
{
    struct plugin_ctx *ctx = flux_plugin_aux_get (p, plugin_name);
    const char *key;
    const char *value;

    if (flux_plugin_arg_unpack (args,
                                FLUX_PLUGIN_ARG_IN,
                                "{s:s}",
                                "key", &key) < 0)
        return upmi_seterror (p, args, "error unpacking get arguments");

    if (json_unpack (ctx->kvs, "{s:s}", key, &value) < 0)
        return upmi_seterror (p, args, "key not found");

    if (flux_plugin_arg_pack (args,
                              FLUX_PLUGIN_ARG_OUT,
                              "{s:s}",
                              "value", value) < 0)
        return -1;
    return 0;
}

static int op_barrier (flux_plugin_t *p,
                       const char *topic,
                       flux_plugin_arg_t *args,
                       void *data)
{
    return 0;
}

static int op_abort (flux_plugin_t *p,
                     const char *topic,
                     flux_plugin_arg_t *args,
                     void *data)
{
    const char *msg;

    if (flux_plugin_arg_unpack (args,
                                FLUX_PLUGIN_ARG_IN,
                                "{s:s}",
                                "msg", &msg) < 0)
        return upmi_seterror (p, args, "error unpacking abort arguments");
    fprintf (stderr, "%s\n", msg);
    exit (1);
    //NOTREACHED
    return 0;
}

/* Populate the kvs with a bizcard for the specified rank.
 * Include only the rank and hostname.
 */
static int put_kvs_bizcard (struct plugin_ctx *ctx,
                            size_t rank,
                            json_t *entry)
{
    struct bizcard *bc;
    const char *host;
    const char *connect = NULL;
    const char *val;
    char key[64];

    if (json_unpack (entry,
                     "{s:s s?s}",
                     "host", &host,
                     "connect", &connect) < 0) {
        errno = EINVAL;
        return -1;
    }
    if (!(bc = bizcard_create (host, NULL)))
        return -1;
    if (connect) {
        if (bizcard_uri_append (bc, connect) < 0)
            goto error;
    }
    snprintf (key, sizeof (key), "%zu", rank);
    if (!(val = bizcard_encode (bc)) || set_string (ctx->kvs, key, val) < 0)
        goto error;
    bizcard_decref (bc);
    return 0;
error:
    bizcard_decref (bc);
    return -1;
}

/* Populate the kvs with bizcards for each configured rank.
 */
static int put_kvs_bizcards (struct plugin_ctx *ctx)
{
    size_t index;
    json_t *entry;

    json_array_foreach (ctx->hosts, index, entry) {
        if (put_kvs_bizcard (ctx, index, entry) < 0)
            return -1;
    }
    return 0;
}

json_t *find_host (json_t *hosts, const char *name, int *rank)
{
    if (hosts) {
        size_t index;
        json_t *entry;
        json_array_foreach (hosts, index, entry) {
            const char *host;
            if (json_unpack (entry, "{s:s}", "host", &host) == 0
                && streq (host, name)) {
                if (rank)
                    *rank = index;
                return entry;
            }
        }
    }
    return NULL;
}

static int op_initialize (flux_plugin_t *p,
                          const char *topic,
                          flux_plugin_arg_t *args,
                          void *data)
{
    struct plugin_ctx *ctx = flux_plugin_aux_get (p, plugin_name);
    flux_error_t error;

    if (conf_bootstrap_parse (ctx->conf,
                              ctx->hostname,
                              NULL,
                              NULL,
                              &ctx->hosts,
                              &error) < 0)
        return upmi_seterror (p, args, "%s", error.text);
    if (!find_host (ctx->hosts, ctx->hostname, &ctx->rank))
        return upmi_seterror (p, args, "%s", "could not determine my rank");
    ctx->size = json_array_size (ctx->hosts);
    if (put_kvs_bizcards (ctx) < 0) {
        return upmi_seterror (p,
                              args,
                              "Error generating rolodex: %s",
                              strerror (errno));
    }
    if (flux_plugin_arg_pack (args,
                              FLUX_PLUGIN_ARG_OUT,
                              "{s:i s:s s:i}",
                              "rank", ctx->rank,
                              "name", plugin_name, // heh, audit this
                              "size", ctx->size) < 0)
        return -1;
    return 0;
}

static int op_finalize (flux_plugin_t *p,
                        const char *topic,
                        flux_plugin_arg_t *args,
                        void *data)
{
    return 0;
}

static int op_preinit (flux_plugin_t *p,
                       const char *topic,
                       flux_plugin_arg_t *args,
                       void *data)
{
    struct plugin_ctx *ctx;
    json_t *config = NULL;
    const char *hostname = NULL;

    if (flux_plugin_arg_unpack (args,
                                FLUX_PLUGIN_ARG_IN,
                                "{s?o s?s}",
                                "config", &config,
                                "hostname", &hostname) < 0)
        return upmi_seterror (p, args, "error unpacking preinit arguments");
    if (!config || !hostname) {
        return upmi_seterror (p,
                              args,
                              "preinit required config/hostname arguments"
                              " are missing");
    }
    if (!json_object_get (config, "bootstrap"))
        return upmi_seterror (p, args, "no [bootstrap] table is configured");
    if (!(ctx = plugin_ctx_create (config, hostname))
        || flux_plugin_aux_set (p,
                                plugin_name,
                                ctx,
                                (flux_free_f)plugin_ctx_destroy) < 0) {
        plugin_ctx_destroy (ctx);
        return upmi_seterror (p, args, "create context: %s", strerror (errno));
    }
    return 0;
}

static const struct flux_plugin_handler optab[] = {
    { "upmi.put",           op_put,         NULL },
    { "upmi.get",           op_get,         NULL },
    { "upmi.barrier",       op_barrier,     NULL },
    { "upmi.abort",         op_abort,       NULL },
    { "upmi.initialize",    op_initialize,  NULL },
    { "upmi.finalize",      op_finalize,    NULL },
    { "upmi.preinit",       op_preinit,     NULL },
    { 0 },
};



int upmi_config_init (flux_plugin_t *p)
{
    if (flux_plugin_register (p, plugin_name, optab) < 0)
        return -1;
    return 0;
}

// vi:ts=4 sw=4 expandtab
